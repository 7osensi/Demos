/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include"stm32f103.h"
#include"Stm32f103_GPIO.h"
#include"Stm32f103_EXTI.h"
#include"Stm32f103_AFIO.h"
#include"Stm32f103_LCD.h"



typedef enum {
	STATE01,
	STATE02,
	NUM_STATES
}StateType;

typedef struct {
	StateType State; // State name
	void(*func)(void); // State function(Code)
}StateMachineType;

/* Functions Prototypes */
void SM_State01(void);
void SM_State02(void);

/* Declare global variables */
StateType CurrentState = STATE01;

/* Array of type StateMachineType */
StateMachineType StateMachine[NUM_STATES] =
{
		{STATE01, SM_State01},
		{STATE02, SM_State02}
};

void SetEvent(StateType event) {
	StateMachine[event].func = 1;
}
//
//void HandleEvent() {
//	if(StateMachine[PB1_EV]) {
//		MCAL_GPIO_ToggleOutputPin(MGPIOA, 2);
//		StateMachine[PB1_EV] = 0;
//	}
//	if(StateMachine[PB4_EV]) {
//		MCAL_GPIO_ToggleOutputPin(MGPIOA, 1);
//		StateMachine[PB4_EV] = 0;
//	}
//}


//void SM_StateA(void) {
//	MCAL_GPIO_ToggleOutputPin(MGPIOA, 2);
//	CurrentState = PB4_EV;
//}
//void SM_StateB(void) {
//	MCAL_GPIO_ToggleOutputPin(MGPIOA, 1);
//	CurrentState = PB1_EV;
//}
//
//void SM_Run() {
//	if(CurrentState < NUM_STATES) {
//		(*StateMachine[CurrentState].func) ();
//	}
//}

int main(void)
{
	/* Activate RCC for GPIOC */
	GPIOA_PCLK_EN();
	/* Activate RCC for GPIOB */
	GPIOB_PCLK_EN();
	/* Activate RCC for GPIOC */
	GPIOC_PCLK_EN();
	/* AFIO Clock Enable */
	AFIO_PCLK_EN();

	/* Initialize LCD */
	HAL_LCD_LCDInit();

	/* Configure PB4 (B10) as input */
	GPIO_PinConfig_t PB_B10 = {10, INPUT_MODE, FLOATING_INPUT};
	GPIO_Handle_t PB4 = {MGPIOB, PB_B10};
	MCAL_GPIO_Init(&PB4);
	/* Configure PB4 (B0) as input */
	GPIO_PinConfig_t PB_B0 = {11, INPUT_MODE, FLOATING_INPUT};
	GPIO_Handle_t PB1 = {MGPIOB, PB_B0};
	MCAL_GPIO_Init(&PB1);

	/* Configure LED_A2 as output */
	GPIO_PinConfig_t LED_A2 = {2, OUTPUT_10MHZ_MODE, GP_OUTPUT_PU_PL_MODE};
	GPIO_Handle_t LED_RED1 = {MGPIOA, LED_A2};
	MCAL_GPIO_Init(&LED_RED1);
	/* Configure LED_A1 as output */
	GPIO_PinConfig_t LED_A1 = {1, OUTPUT_10MHZ_MODE, GP_OUTPUT_PU_PL_MODE};
	GPIO_Handle_t LED_RED2 = {MGPIOA, LED_A1};
	MCAL_GPIO_Init(&LED_RED2);

	/*==================== Interrupt Configurations for PB10 ====================*/
	MCAL_GPIO_IRQConfig(40 , EXTI_ENABLE);
	MCAL_AFIO_SelectPort(10, 1); /* Line Number, Port ID */
	MCAL_EXTI_InterruptEdgeType(10, EXTI_F_EDGE);
	MCAL_EXTI_Enable(10);
	/*==================== Interrupt Configurations for SW4 ====================*/
	MCAL_GPIO_IRQConfig(6 , EXTI_ENABLE);
	MCAL_AFIO_SelectPort(0, 1); /* Line Number, Port ID */
	MCAL_EXTI_InterruptEdgeType(0, EXTI_F_EDGE);
	MCAL_EXTI_Enable(0);

    /* Loop forever */
	for(;;) {
//		HandleEvent();
//		SM_Run();
	}
}

/* PB2 */
void EXTI15_10_IRQHandler(void) {
	SetEvent(PB1_EV);
	MCAL_GPIO_IRQHandling(GPIO_PIN_NO_10);
	MCAL_GPIO_ToggleOutputPin(MGPIOA, GPIO_PIN_NO_2);
//	HAL_LCD_LCDClear();
//	HAL_LCD_LCDWriteString("Hello from ST1");
}

/* PB4 */
void EXTI0_IRQHandler(void) {
//	SetEvent(PB4_EV);
	MCAL_GPIO_IRQHandling(GPIO_PIN_NO_0);
	MCAL_GPIO_ToggleOutputPin(MGPIOA, GPIO_PIN_NO_1);
//	HAL_LCD_LCDClear();
//	HAL_LCD_LCDWriteString("Hello from ST2");
}
